(ns genetic-clojure.core
  (:use [clojure.contrib.math]))

(def alphabet
     "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!? ")

(def target
     "Hello Clojure World!")

(defn difference-between-chars
  "Returns the distance between the int representations of two chars"
  [a b]
  (abs (- (int a) (int b))))

(defn fitness
  "Determines the fitness of a given chromo based on how far each of its
  characters are from the target string"
  [chromo]
  (reduce + (map difference-between-chars chromo target)))

(defn random-char
  "Returns a random char in our alphabet"
  []
  (rand-nth alphabet))

(defn breed
  "Breeds two chromos together by splitting them at position and combining the
  first half of the first string with the second half of the second string."
  ([s1 s2 position]
     (apply str (concat (take position s1) (drop position s2)))))

(defn breed-with-mutation
  "Breeds two chromos together like (breed), but inserts a random charactor at
  position"
  ([s1 s2 position]
     (apply str (concat
                 (take position s1)
                 (list (random-char))
                 (drop (+ position 1) s2)))))

(defn breed-wrapper
  "Decides whether to breed cleanly or with a mutation. Also provides a random
  position for breeding if not provided"
  ([s1 s2]
     ;; No position was passed in- let's generate a random one
     (breed-wrapper s1 s2 (rand-int (count s1))))
  ([s1 s2 position]
     (if (< 0 (rand-int 2))
            (breed s1 s2 position)
            (breed-with-mutation s1 s2 position))))

(defn create-random-chromo
  "Creates a string of the given length composed of random letters"
  [length]
  (apply str (take length (repeatedly random-char))))

(defn generate-random-sample
  []
  (repeatedly 1000 #(create-random-chromo (count target))))

(defn sort-by-fitness
  [list]
  (sort-by #(fitness %) list))

(defn tourny-select-chromo
  "Takes a list of chromos, selects two at random, and returns the one with
  best fitness"
  [list]
  (first (sort-by-fitness (take 2 (repeatedly #(rand-nth list))))))

(defn generate-selected
  "The selected group is generated by taking the best 10 chromos (elitism),
  then repeated calling tourny-select on the sample to generate 90 more."
  [sample]
  (concat 
    (take 10 sample)
    (take 90 (repeatedly #(tourny-select-chromo sample)))))

(defn generate-solution
  "Generates the solution set by repeatedly selecting two chromos (at random)
  from selected and breeding them"
  [selected]
  (repeatedly 1000
              (fn [] (breed-wrapper (rand-nth selected) (rand-nth selected)))))

(defn run-generation
  [sample]
  (generate-solution (generate-selected sample)))

(defn run
  ([]
     (run (generate-random-sample)))
  ([sample]
     (let [solution (sort-by-fitness (run-generation sample))]
       (do
         (println (fitness (first solution)) (first solution))
         (if (= (fitness (first solution)) 0)
           solution
           (run solution))))))
