(ns genetic-clojure.core
  (:use [clojure.contrib.math]))

(def alphabet
     "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!? ")

(def target
     "Hello Clojure World!")

(defn difference-between-chars
  "Returns the distance between the int representations of two chars"
  [a b]
  (abs (- (int a) (int b))))

(defn fitness
  "Determines the fitness of a given chromo based on how far each of its
  characters are from the target string"
  [chromo]
  (reduce + (map difference-between-chars chromo target)))

(defn breed
  "Breeds two chromos together by splitting them in a random place and
  combining the first half of the first string with the second half of the
  second string."
  ([s1 s2]
     ;; No position was passed in- let's generate a random one
     (breed s1 s2 (rand-int (count s1))))
  ([s1 s2 position]
     (apply str (concat (take position s1) (drop position s2)))))

(defn random-char
  "Returns a random char in our alphabet"
  []
  (rand-nth alphabet))

(defn create-random-chromo
  "Creates a string of the given length composed of random letters"
  [length]
  (apply str (take length (repeatedly random-char))))

(defn generate-random-sample
  []
  (repeatedly 1000 #(create-random-chromo (count target))))

(defn sort-by-fitness
  [list]
  (sort-by #(fitness %) list))

(defn tourny-select-chromo
  "Takes a list of chromos, selects two at random, and returns the one with
  best fitness"
  [list]
  (first (sort-by-fitness (take 2 (repeatedly #(rand-nth list))))))

(defn generate-selected
  "The selected group is generated by repeated tourny-select from the sample"
  [sample]
  (take 100 (repeatedly #(tourny-select-chromo sample))))

(defn generate-solution
  "Generates the solution set by repeatedly selecting two chromos (at random)
  from selected and breeding them"
  [selected]
  (repeatedly 1000 (fn [] (breed (rand-nth selected) (rand-nth selected)))))


(defn run-loop
  [sample]
  (generate-solution (generate-selected sample)))

(defn run
  ([]
     (run (generate-random-sample)))
  ([sample]
     (let [solution (sort-by-fitness (run-loop sample))]
       (do
         (println (first solution))
         (if (= (fitness (first solution)) 0)
           solution
           (run solution))))))
